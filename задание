Задание
Цель задания и описание

Вы пришли работать разработчиком в компанию, занимающуюся провайдингом  современных средств коммуникации. Компания предоставляет инструменты и API для автоматизации работы систем SMS, MMS, голосовых звонков и email. География клиентов распространяется на 160 стран, и компания быстро растёт. Требуется всё больше ресурсов со стороны службы поддержки, и было принято решение снизить количество заявок с помощью создания страниц информирования клиентов о текущем состоянии систем. 

С помощью этих страниц компания планирует снизить количество однотипных  вопросов и высвободить время агентов службы поддержки для решения более сложных задач. В числе прочего были составлены страницы с ответами на часто задаваемые вопросы, уведомления о неполадках и истории инцидентов, чтобы клиенты могли самостоятельно проверять действующие системы на работоспособность. 

Поскольку компания работает на широкую аудиторию и распространена по всему миру, практически невозможно уследить за всеми изменениями вручную, поэтому каждое подразделение компании самостоятельно контролирует работу поставщиков услуг, в автоматизированном режиме храня эти данные. 

Вашей задачей становится финализировать проект, объединив эти данные и разработав небольшой сетевой сервис, который будет принимать запросы по сети и  возвращать данные о состоянии систем компании. Эти данные будут выводиться на веб-страницу сайта компании и содержать в себе StatusPage, географию и статусы сервисов. Так клиенты смогут проверить свой регион на наличие ошибок, прежде чем обращаться в службу поддержки. 

Ниже вы найдёте все технические подробности реализации сетевого домена, которые помогут вам создать работающее приложение. Они разбиты на несколько небольших этапов. По каждому этапу подробно расписано, что необходимо сделать и как проверить конечный результат. 
Задача состоит из следующих этапов:

    Подготовка.
    Сбор данных о системе SMS.
    Сбор данных о системе MMS.
    Сбор данных о системе VoiceCall.
    Сбор данных о системе email.
    Сбор данных о системе Billing.
    Сбор данных о системе Support.
    Сбор данных о системе истории инцидентов.
    Подготовка сетевого сервиса.
    Подготовка структур.
    Сортировка и фильтрация данных.


Этап 1. Подготовка
Цель этапа

Подготовить всё необходимое программное обеспечение, чтобы начать  программировать сетевой сервис. 
Что нужно сделать 

    Установите на свой компьютер среду разработки GoLand, если она ещё не установлена.
    Установите на свой компьютер Git, если он ещё не установлен.
    Ознакомьтесь с кодами стран в формате ISO 3166-1 alpha-2, который используется в проекте для идентификации стран. 
    Ознакомьтесь с форматом файлов CSV (часть данных в проекте хранится в этом формате).
    Создайте директорию рядом с проектом диплома, перейдите в неё и склонируйте проект симулятора данных в отдельную директорию GitHub с помощью команды.

    git clone ./ https://github.com/antondzhukov/skillbox-diploma

    После этого сделайте следующее:

    go mod init github.com/antondzhukov/skillbox-diploma

    В соответствии с файлом Readme в проекте симулятора запустите проект. Проект сгенерирует нужные файлы и продолжит работать для обращения к нему по API для получения дополнительных данных, которые мы рассмотрим ниже. 
    На этапе сбора данных рекомендуется проверять работу функций сбора, добавляя их в выполнение внутри функции main() и выводя результат в консоль с помощью дебаггера или функции:

    fmt.Printf()


Этап 2. Сбор данных о системе SMS
Цель этапа

Реализовать функцию получения данных о состоянии системы SMS из файла формата CSV. 
Что нужно сделать

    Напишите функцию, которая будет читать всё содержимое из файла, после чего обходить содержимое построчно и разбирать строки на показатели. 
    Для чтения из файла должен использоваться пакет ioutil. 
    Файл должен быть записан в формате CSV. 
    Данные в строках должны быть разделены с помощью знака. Чтобы разбить строку на поля, можно использовать функцию:

    Каждая строка должна содержать четыре поля:
        alpha-2 — код страны;
        пропускная способность канала от 0 до 100%;
        среднее время ответа в миллисекундах;
        название компании-провайдера.
    Строки, содержащие отличное количество полей, не должны попадать в результат работы функции. Проверить количество элементов в срезе можно с помощью функции len().

    Некоторые строки могут быть повреждены, их нужно пропускать и не записывать в результат выполнения функции. В результат допускаются только страны, прошедшие проверку на существование по коду alpha-2.
    Рекомендуется скопировать список стран в свой проект, составить по нему map и написать функцию, проверяющую существование страны. В результат допускаются только корректные провайдеры. Допустимые провайдеры:
        Topolo
        Rond
        Kildy.
    Все некорректные провайдеры нужно пропускать и не добавлять в результат работы функции.

    Строки, в которых меньше четырёх полей данных, не допускаются. 
    Результатом работы функции должен быть срез, содержащий структуры из четырёх полей с набором данных каждой строки. Например, строка BG;42;501;Rond может быть трансформирована в структуру:

    type SMSData struct { 
        Сountry string 
        Bandwidth string 
        ResponseTime string
        Provider string 
    }

Как проверить работу функции

    Реализуйте функцию получения данных о состоянии системы SMS из файла формата CSV. 
    Запустите симулятор.
    Симулятор сгенерирует файл в своей директории sms.data. 
    Запустите свой проект для вывода результата в консоль fmt.Printf() с помощью функции или для проверки результата работы функции дебаггером. 
    Откройте файл в директории проекта симулятора sms.data. 
    Сравните содержимое файла с результатом вывода консоли или содержимым переменной в отладчике. 
    Пример файла: 

    U5;41910;Topol US;36;1576;Rond GB28495Topolo F2;9;484;Topolo BL;68;1594;Kildy 

    В результирующий набор должны попасть две структуры, содержащие данные из строк:

    US;36;1576;Rond BL;68;1594;Kildy 

        Строка 1 не попадёт в результат из-за некорректности провайдера.
        Строка 3 не попадёт из-за отсутствия разделителей и возможности получить четыре элемента данных.
        Строка 4 не попадёт из-за некорректного кода страны.


Этап 3. Сбор данных о системе MMS
Цель этапа

Реализовать функцию получения данных о состоянии системы MMS, опрашивая API системы через HTTP-GET-запрос. Структура в целом похожа на действия с SMS, но возвращается в виде JSON. 
Что нужно сделать

    Напишите функцию, которая будет отправлять GET-запрос по адресу 127.0.0.1:8383, разбирать полученный ответ в срез структур и возвращать его в https://golang.org/pkg/net/http/. 
    Используя пакет, отправьте GET-запрос по адресу 127.0.0.1:8383. 
    Полученный ответ переведите в срез []byte с помощью функции io.ReadAll.
    Полученный срез переведите в срез структур вида: 

    type MMSData struct {  
        Country string `json:"country"` 
        Provider string `json:"provider"` 
        Bandwidth string `json:"bandwidth"` 
        ResponseTime string `json:"response_time"` 
    } 

    Обратите внимание: API не всегда возвращает корректный ответ, поэтому проверяйте код ответа. Если он равен 200, можно переводить полученный ответ в структуры, если код равен 500 — произошла ошибка.
    Состав полей соответствует структуре из пункта 3. Для разбора полученного JSON в срез структур используйте функцию:

    json.Unmarshal 

    Поле country может содержать только код alpha-2 из общего списка стран. Если страна отсутствует в общем списке, этот элемент нужно удалить из результата работы функции. Допустимые провайдеры MMS: 
        Topolo,
        Rond, 
        Kildy. 
    Если провайдер элемента не соответствует одному из представленных, этот элемент должен быть удалён из результатов работы функции.

    В случае ошибки со стороны API-симулятора или разбора запустите свой проект для вывода результата в консоль с помощью функции или для проверки результата:

    fmt.Printf()  

    Выведите в консоль или дебаггер результат, полученный из GET-запроса.


Этап 4. Сбор данных о системе VoiceCall
Описание этапа

Общий принцип работы VoiceCall похож на SMS, но в данном случае мы сталкиваемся с более широким набором значений. Компания старается улучшать качество системы, поэтому делает тестовые звонки, позволяет их записывать и оценивает параметры, влияющие на разговор.
Цель этапа

Реализовать функцию получения данных о состоянии системы VoiceCall из файла формата CSV. Разбор файла в целом похож на действия с SMS, но содержит дополнительные условия. 
Что нужно сделать

    Напишите функцию, которая будет читать всё содержимое из файла, после чего обходить содержимое построчно и разбирать строки на показатели. 
    Для чтения из файла должен использоваться пакет ioutil. 
    Файл записан в формате CSV. 
    Данные в строках разделены с помощью точки с запятой. Чтобы разбить строку на поля, можно использовать функцию:

    strings.Split() 

    Каждая строка должна содержать восемь полей: 
        alpha-2 — код страны;
        текущая нагрузка в процентах;
        среднее время ответа;
        провайдер;
        стабильность соединения;
        чистота TTFB-связи; 
        медиана длительности звонка.
    Строки, содержащие отличное количество полей, не должны попадать в результат работы функции. Проверить количество элементов в срезе можно с помощью функции len().
    Некоторые строки могут быть повреждены, их нужно пропускать и не записывать в результат выполнения функции.
    В результат допускаются только страны, прошедшие проверку на существование по коду alpha-2. 
    В результат допускаются только корректные провайдеры. Допустимые провайдеры: 
        TransparentCalls,
        E-Voice,
        JustPhone. 
    Все некорректные провайдеры нужно пропускать и не добавлять в результат работы функции.
    Строки, в которых меньше восьми полей данных, не допускаются. Все целочисленные данные должны быть приведены к типу int. 
    Все числа с плавающей точкой должны быть приведены к типу float32.
    Результатом работы функции должен быть срез, содержащий структуры из восьми полей с набором данных каждой строки. 
    Например, строка MC;25;1274;E-Voice;0.51;46;68;24 может быть трансформирована в структуру.


Этап 5. Сбор данных о системе email
Описание этапа

Для оценки качества доставки писем компания самостоятельно раз в минуту отправляет письма каждому провайдеру на почтовые ящики, распределённые по всему миру, и с помощью API проверяет, через какое время приходит письмо. Письма отправляются от разных провайдеров, чтобы получить медианное время доставки. Значение 0 в значении времени доставки означает, что письмо не было получено в течение часа. 
Цель этапа

Реализовать функцию получения данных о состоянии системы email из файла формата CSV. Разбор файла в целом похож на действия с SMS и VoiceCall, но содержит дополнительные условия.
Что нужно сделать

    Напишите функцию, которая будет читать всё содержимое из файла, после чего обходить содержимое построчно и разбирать строки на показатели.
    Для чтения из файла должен использоваться пакет ioutil.
    Файл записан в формате CSV. 
    Данные в строках разделены с помощью точки с запятой. Чтобы разбить строку на поля, можно использовать функцию strings.Split(). 
    Каждая строка должна содержать три поля:
        alpha-2 — код страны;
        провайдер;
        среднее время доставки писем в миллисекундах.
    Строки, содержащие отличное количество полей, не должны попадать в результат работы функции. Проверить количество элементов в срезе можно с  помощью функции len().
    Некоторые строки могут быть повреждены, их нужно пропускать и не записывать в результат выполнения функции. 
    В результат допускаются только страны, прошедшие проверку на существование по коду alpha-2. 
    В результат допускаются только корректные провайдеры. Допустимые провайдеры:
        Gmail, 
        Yahoo, 
        Hotmail, 
        MSN, 
        Orange, 
        Comcast, 
        AOL, 
        Live, 
        RediffMail, 
        GMX, 
        Proton Mail, 
        Yandex, 
        Mail.ru.
    Все некорректные провайдеры нужно пропускать и не добавлять в результат работы функции. 
    Строки, в которых меньше трёх полей данных, не допускаются. 
    Время доставки письма должно быть приведено к типу int. 
    Результатом работы функции должен быть срез, содержащий структуры из трёх полей с набором данных каждой строки. 
    Например, строка RU;Gmail;581 может быть трансформирована в структуру:

    type EmailData struct {
       Country string
       Provider string
       DeliveryTime int 
    }


Этап 6. Сбор данных о системе Billing
Описание этапа

Помимо систем провайдинга услуг, у компании есть автоматизированная система  биллинга для реализации оплаты услуг в ручном и автоматизированном режиме.  Команда биллинга контролирует свои сервисы как простое состояние «работает / не работает» и для экономии места использует битовую маску. 
Цель этапа

Реализовать функцию получения данных о состоянии системы Billing из файла,  содержащего битовую маску состояния систем. Каждый бит отвечает за состояние  отдельной системы. Системы по порядку: создание клиента, оплата, выплата, платежи по подписке, контроль мошенничества, страница оплаты. 
Что нужно сделать

    Для чтения из файла должен использоваться пакет ioutil. Файл содержит битовую маску.
    Необходимо помнить, что отсчёт битов в битовой маске начинается справа.
    Полученная строка должна быть разбита на срез байтов и с помощью  возведения в степень каждого бита интерпретирована в число. Сумма степеней каждого бита должна быть присвоена переменной с типом uint8. 
    Например, мы имеем маску вида 00010011. Все нулевые биты мы пропускаем. Каждый бит с единицей возводится в степень своего номера. Таким образом, можно посчитать число следующим способом (справа налево): 2^0 + 2^1 + 0 + 0 + 2^4 + 0 + 0 + 0 = 19. Каждый бит со значением 1 был использован для возведения двойки в степень номера бита. Мы возвели в степень 0-й, 1-й и 4-й биты и сложили результаты, остальные проигнорировали.
    С помощью полученного числа и булевых операций нужно выделить каждый бит и проверить его на соответствие. Если бит проходит проверку, значение поля в структуре должно быть True. Если равен 0, то False. 
    Результаты булевых операций нужно сохранить в структуру вида:

    type BillingData struct { 
       CreateCustomer bool 
       Purchase bool 
       Payout bool 
       Recurring bool 
       FraudControl bool 
       CheckoutPage bool 
    } 


Этап 7. Сбор данных о системе Support
Цель этапа

Написать функцию, которая будет получать данные о текущей загрузке команды  службы поддержки по API для дальнейшего прогноза потенциального времени  ожидания ответа. 
Что нужно сделать 

    Напишите функцию, которая будет отправлять GET-запрос по адресу 127.0.0.1:8484, разбирать полученный ответ в срез структур и возвращать его.
    Используя пакет, отправьте GET-запрос по адресу 127.0.0.1:8484. Полученный ответ переведите в срез []byte с помощью функции io.ReadAll. 
    Полученный срез переведите в срез структур вида: 2

    type SupportData struct { 
       Topic string `json:"topic"` 
       ActiveTickets int `json:"active_tickets"` 
    } 

    Обратите внимание: API не всегда возвращает корректный ответ. Проверяйте код ответа. Если он равен 200, можно переводить полученный ответ в  структуры, если код равен 500 — произошла ошибка.
    Состав полей соответствует структуре из пункта 3. Для разбора полученного JSON в срез структур используйте функцию json.Unmarshal.
    В случае ошибки со стороны API-симулятора или разбора JSON в структуру возвращайте в виде ответа пустой срез []SupportData.


Этап 8. Сбор данных о системе истории инцидентов
Описание этапа

В общем потоке данных система истории инцидентов просто содержит массив  инцидентов за последнюю неделю. Мы будем возвращать нашим пользователям  историю инцидентов, чтобы разгрузить службу поддержки от однообразных вопросов. 

Например, у нас происходят неполадки в системе SMS, и служба поддержки создаёт инцидент. Пользователи на нашей странице StatusPage могут посмотреть, что у нас неполадки, и на какое-то время отключить свои системы, чтобы до завершения работ по восстановлению не создавать новых тикетов support’у. Таким образом, мы сообщаем нашим пользователям о возможных и уже решённых проблемах с сервисами. 
Цель этапа

Написать функцию, которая будет отправлять GET-запрос по адресу 127.0.0.1:8585, разбирать полученный ответ в срез структур и возвращать его.
Что нужно сделать

    Используя пакет, отправьте GET-запрос по адресу 127.0.0.1:8585.
    Полученный ответ переведите в срез []byte с помощью функции io.ReadAll.
    Полученный срез переведите в срез структур вида:

    type IncidentData struct { 
     Topic string `json:"topic"` 
     Status string `json:"status"` // возможные статусы active и closed 
    }

    Обратите внимание: API не всегда возвращает корректный ответ. Проверяйте код ответа. Если он равен 200, можно переводить полученный ответ в  структуры, если код равен 500 — произошла ошибка.
    Состав полей соответствует структуре из пункта 3. В случае ошибки со стороны API-симулятора или разбора JSON в структуру возвращайте в виде ответа пустой срез:

     []IncidentData


Этап 9. Подготовка сетевого сервиса
Цели этапа

Подготовить программу к работе по сети. 

Организовать открытие сетевого соединения и провести первичное тестирование обработки запросов. 
Что нужно сделать

    Напишите функцию, которая будет отправлять GET-запрос по адресу 127.0.0.1:8585, разбирать полученный ответ в срез структур и возвращать его. 
    Создайте HTTP-сервер с помощью http.Server из пакета net/http. Сервер должен слушать localhost и порт, например (localhost:8282). 
    Создайте mux и добавьте его в сервер. Можно использовать HTTP-фреймворки, такие как gin, chi, gorilla и другие.
    С помощью функции mux.NewRouter() создайте новый роутер и добавьте ему  обработку адреса «/» на функцию handleConnection (используйте документацию на странице для примеров использования роутера). 
    Напишите функцию handleConnection по примеру функции  ArticlesCategoryHandler из документации. Ваша функция должна возвращать только слово OK. Назначьте серверу из пункта 1 получившийся роутер. 
    Откройте соединение функцией ListenAndServe() сервера.


Этап 10. Подготовка структур
Цель этапа 

Перед тем как возвращать данные по запросу, нужно подготовить структуры к автоматической конвертации в JSON. 
Что нужно сделать 

    Напишите функцию, которая будет отправлять GET-запрос по адресу 127.0.0.1:8585, разбирать полученный ответ в срез структур и возвращать его. 
    Каждая структура содержит свойство, напротив которого нужно проставить тег  `json:"название_поля"`. Название поля должно быть трансформировано Snake case. Например, свойство Country будет трансформировано в country, а ProviderName — в provider_name. 
    Дополните все свойства структур, полученных на этапе сбора данных, тегами JSON с трансформированным названием поля.
    Подготовьте родительские структуры ResultT и ResultSetT, которые будут  содержать следующие поля:

       type ResultT struct {
           Status bool       `json:"status"` // True, если все этапы сбора данных прошли успешно, False во всех остальных случаях
           Data   ResultSetT `json:"data"`   // Заполнен, если все этапы сбора  данных прошли успешно, nil во всех остальных случаях
           Error  string     `json:"error"`  // Пустая строка, если все этапы сбора данных прошли успешно, в случае ошибки заполнено текстом ошибки
       }


    (детали ниже)

    type ResultSetT struct {
           SMS       [][]SMSData              `json:"sms"`
           MMS       [][]MMSData              `json:"mms"`
           VoiceCall []VoiceCallData          `json:"voice_call"`
           Email     map[string][][]EmailData `json: email"`
           Billing   BillingData              `json: billing"`
           Support   []int                    `json: support"`
           Incidents []IncidentData           `json:"incident"`
       }


Этап 11. Сортировка и фильтрация данных
Описание этапа

Полученные наборы данных необходимо подготовить для возврата браузеру в нужном формате и количестве. Для отображения данные должны быть отсортированы и дополнительно отфильтрованы, чтобы показывать их клиентам в удобном для просмотра виде. 
Цель этапа

Обойти все этапы сбора данных и составить результирующий набор с помощью  родительских структур ResultT и ResultSetT. 
Что нужно сделать

    Напишите функцию func getResultData() ResultSetT{}, которая будет обходить все  этапы сбора данных и возвращать готовый для возврата набор. 
    Получите данные по SMS и подготовьте два отсортированных списка (используйте приёмы из модуля «Сортировка массивов»). 
    Подмените коды стран в структурах SMSData на полные названия стран, основываясь на списках кодов alpha-2. Первый набор должен быть отсортирован по названию провайдера от A до Z. Второй набор должен быть отсортирован по названию страны от A до Z. 
    Объедините оба набора в срез. У вас должен получиться срез вида  [][]SMSData, содержащий два среза с отсортированными данными. 
    Запишите данные в свойство SMS-структуры ResultSetT
    Получите данные по MMS и подготовьте два отсортированных списка (используйте приёмы из модуля «Сортировка массивов»). 
    Подмените коды стран в структурах MMSData на полные названия стран, основываясь на списках кодов alpha-2. Первый набор должен быть отсортирован по названию провайдера от A до Z. Второй набор должен быть отсортирован по названию страны от A до Z. 
    Объедините оба набора в срез. У вас должен получиться срез вида [][]MMSData, содержащий два среза с отсортированными данными. 
    Запишите данные в свойство MMS-структуры .
    Получите данные по ResultSetT
    VoiceCall. Эти данные никак не нужно модифицировать.  Можно напрямую заполнить []VoiceCall в ResultSetT. 
    Получите данные по email. Вам нужно отсортировать всех провайдеров в каждой стране по показателю среднего времени доставки письма и составить из этого карту с ключом кода страны (map[string][]EmailData) и двумя срезами внутри. Первый должен содержать три самых быстрых провайдера, второй — три самых медленных. 
    Запишите данные в свойство email структуры ResultSetT.
    Данные о системе Billing никак не нужно модифицировать. Можно напрямую заполнить Billing в ResultSetT. Если вы не выполняли это задание, пропустите заполнение свойства Billing. 
    Получите данные о системе Support:
        средняя пропускная способность — 18 тикетов в час;
        до девяти — support не нагружен; 
        9–16 — средняя нагрузка;
        >16 — перегружен. 
    Support разделён на специалистов по темам. Если в какой-то теме мало запросов, их перебрасывают в другие. При этом профильные задачи решаются в первую очередь, поэтому общая нагрузка не влияет на решение профильных задач. 
    Нужно возвращать наружу общее состояние нагрузки в виде инта (1, 2, 3) по степени нагрузки и потенциальное время ожидания по каждому профилю задач. 
    Всего в службе поддержки семь специалистов. Мы используем упрощённую систему расчёта: (60 минут / 18 тикетов в час) = Количество минут, которое семь человек в среднем тратят на один тикет. Исходя из среднего количества минут на тикет и суммы открытых тикетов, посчитайте потенциальное время ожидания ответа на новый тикет, умножив количество открытых тикетов на количество минут на тикет. Запишите в ResultSetT срез из двух int, первый из которых будет показывать загруженность службы поддержки (1–3), а второй — среднее время ожидания ответа.
    Получите данные об истории инцидентов. 
    Отсортируйте полученные данные так, чтобы все инциденты со статусом active оказались наверху списка, а остальные были расположены ниже. Порядок остальной сортировки не важен. Запишите данные в свойство Support структуры ResultSetT.


Критерии оценки 

Незачёт:

    Реализовано менее семи этапов в соответствии с ТЗ.
    Нарушены функциональные и технологические требования.
    Код не проходит проверку линтерами.
    Функции, переменные, классы названы некорректно.
    Проект не компилируется, есть проблемы со сборкой и запуском.
    Проект не выложен на GitHub и (или) отсутствуют необходимые файлы для сборки.


Зачёт:

    Реализовано семь и более этапов в соответствии с ТЗ.
    Соблюдены функциональные и технологические требования.
    Код оформлен в соответствии с golangci-lint.
    Все функции, переменные, классы имеют корректные названия.
    Проект компилируется, собирается и запускается.
    Проект выложен на GitHub со всеми необходимыми файлами для сборки.


Формат сдачи

Допуск к итоговой аттестации осуществляется после 100% выполнения всех промежуточных аттестаций. 

Исходники и документация должны быть выложены на GitHub.

В файле REAMDE.md нужно описать пошагово как запустить систему:

    Последовательный список команд для запуска
    Ожидаемый результат выполнения
    Примеры запросов, чтобы можно было сделать copy / paste

О дате, времени и формате проведения защиты будет сообщено дополнительно.